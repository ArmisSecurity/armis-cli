name: Reusable Armis Security Scan

on:
  workflow_call:
    inputs:
      scan-type:
        description: 'Type of scan to perform: repo or image'
        type: string
        default: 'repo'
      scan-target:
        description: 'Target to scan (path for repo, image name for image scan)'
        type: string
        default: '.'
      fail-on:
        description: 'Comma-separated severity levels to fail on (e.g., HIGH,CRITICAL)'
        type: string
        default: 'CRITICAL'
      pr-comment:
        description: 'Post scan results as PR comment'
        type: boolean
        default: true
      upload-artifact:
        description: 'Upload SARIF results as artifact'
        type: boolean
        default: true
      artifact-retention-days:
        description: 'Number of days to retain artifacts'
        type: number
        default: 30
      image-tarball:
        description: 'Path to image tarball (only for image scans)'
        type: string
        default: ''
      scan-timeout:
        description: 'Scan timeout in minutes'
        type: number
        default: 60
      include-files:
        description: 'Comma-separated list of file paths to scan (relative to repository root)'
        type: string
        default: ''
      build-from-source:
        description: 'Build CLI from source instead of downloading release (for testing scanner changes)'
        type: boolean
        default: false
    secrets:
      api-token:
        description: 'Armis API token for authentication'
        required: true
      tenant-id:
        description: 'Tenant identifier for Armis Cloud'
        required: true

# Top-level permissions define the maximum permissions available to this workflow.
# Job-level permissions further restrict as needed.
permissions:
  contents: read
  security-events: write
  actions: read
  pull-requests: write

jobs:
  security-scan:
    name: Armis Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 135
    permissions:
      contents: read
      security-events: write
      actions: read
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Run Armis Security Scan
        id: armis_scan
        uses: ./
        with:
          scan-type: ${{ inputs.scan-type }}
          scan-target: ${{ inputs.scan-target }}
          api-token: ${{ secrets.api-token }}
          tenant-id: ${{ secrets.tenant-id }}
          format: sarif
          fail-on: ${{ inputs.fail-on }}
          output-file: armis-results.sarif
          image-tarball: ${{ inputs.image-tarball }}
          scan-timeout: ${{ inputs.scan-timeout }}
          include-files: ${{ inputs.include-files }}
          build-from-source: ${{ inputs.build-from-source }}
        continue-on-error: true

      - name: Ensure SARIF exists
        if: always()
        run: |
          if [ ! -s armis-results.sarif ]; then
            echo '{"version":"2.1.0","$schema":"https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json","runs":[{"tool":{"driver":{"name":"armis-cli","version":"1.0.0"}},"results":[]}]}' > armis-results.sarif
          fi

      - name: Post PR Comment with Results
        if: always() && inputs.pr-comment && github.event_name == 'pull_request'
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');

            // Read SARIF results
            const sarif = JSON.parse(fs.readFileSync('armis-results.sarif', 'utf8'));
            const results = sarif.runs?.[0]?.results || [];

            // Count by severity - read from properties.severity if available
            const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, INFO: 0 };
            for (const r of results) {
              // Prefer properties.severity (set by armis-cli), fallback to level mapping
              const severity = r.properties?.severity || {
                'error': 'HIGH',
                'warning': 'MEDIUM',
                'note': 'LOW',
                'none': 'INFO'
              }[r.level || 'warning'] || 'INFO';
              counts[severity]++;
            }
            const total = results.length;

            // Build comment body
            const marker = '<!-- armis-security-scan -->';
            const status = counts.CRITICAL > 0 ? 'ðŸ”´ CRITICAL issues found' :
                           counts.HIGH > 0 ? 'ðŸŸ  HIGH issues found' :
                           total > 0 ? 'ðŸŸ¡ Issues found' : 'âœ… No issues';

            let body = `${marker}\n## ðŸ›¡ï¸ Armis Security Scan Results\n\n**${status}**\n\n`;
            body += `| Severity | Count |\n|----------|-------|\n`;
            if (counts.CRITICAL > 0) body += `| ðŸ”´ CRITICAL | ${counts.CRITICAL} |\n`;
            if (counts.HIGH > 0) body += `| ðŸŸ  HIGH | ${counts.HIGH} |\n`;
            if (counts.MEDIUM > 0) body += `| ðŸŸ¡ MEDIUM | ${counts.MEDIUM} |\n`;
            if (counts.LOW > 0) body += `| ðŸ”µ LOW | ${counts.LOW} |\n`;
            if (counts.INFO > 0) body += `| âšª INFO | ${counts.INFO} |\n`;
            body += `\n**Total: ${total}**\n`;

            // Build detailed findings section
            if (total > 0) {
              body += `\n<details><summary>View all ${total} findings</summary>\n\n`;

              // Group results by severity
              const severityOrder = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO'];
              const severityEmoji = { CRITICAL: 'ðŸ”´', HIGH: 'ðŸŸ ', MEDIUM: 'ðŸŸ¡', LOW: 'ðŸ”µ', INFO: 'âšª' };

              for (const severity of severityOrder) {
                const severityResults = results.filter(r =>
                  (r.properties?.severity || 'INFO') === severity
                );

                if (severityResults.length > 0) {
                  body += `### ${severityEmoji[severity]} ${severity} (${severityResults.length})\n\n`;

                  for (const r of severityResults) {
                    const file = r.locations?.[0]?.physicalLocation?.artifactLocation?.uri || '';
                    const line = r.locations?.[0]?.physicalLocation?.region?.startLine || '';
                    const location = file ? (line ? `${file}:${line}` : file) : 'Unknown location';

                    // Parse title and description from message
                    const msgParts = (r.message?.text || '').split(': ');
                    const title = msgParts[0] || r.ruleId;
                    const description = msgParts.slice(1).join(': ') || '';

                    body += `<details><summary><code>${r.ruleId}</code> - ${title}</summary>\n\n`;
                    body += `**Location:** \`${location}\`\n\n`;

                    if (description) {
                      body += `${description}\n\n`;
                    }

                    // Code snippet
                    const snippet = r.properties?.codeSnippet;
                    if (snippet) {
                      body += '```\n' + snippet + '\n```\n\n';
                    }

                    // CVEs and CWEs
                    const cves = r.properties?.cves || [];
                    const cwes = r.properties?.cwes || [];
                    if (cves.length > 0) {
                      body += `**CVEs:** ${cves.join(', ')}\n\n`;
                    }
                    if (cwes.length > 0) {
                      body += `**CWEs:** ${cwes.join(', ')}\n\n`;
                    }

                    // Package info
                    const pkg = r.properties?.package;
                    const version = r.properties?.version;
                    const fixVersion = r.properties?.fixVersion;
                    if (pkg) {
                      let pkgInfo = `**Package:** ${pkg}`;
                      if (version) pkgInfo += ` (${version})`;
                      if (fixVersion) pkgInfo += ` â†’ Fix: ${fixVersion}`;
                      body += pkgInfo + '\n\n';
                    }

                    body += `</details>\n\n`;
                  }
                }
              }

              body += `</details>`;
            } else {
              body += `\n<details><summary>View full results</summary>\n\nNo security issues found.\n</details>`;
            }

            // Find and update existing comment, or create new
            const { data: comments } = await github.rest.issues.listComments({
              ...context.repo,
              issue_number: context.issue.number
            });
            const existing = comments.find(c => c.body.includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                ...context.repo,
                comment_id: existing.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: context.issue.number,
                body
              });
            }

      - name: Upload SARIF to GitHub Code Scanning
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        continue-on-error: true
        with:
          sarif_file: armis-results.sarif
          category: armis-security-scan

      - name: Upload SARIF as Artifact
        if: always() && inputs.upload-artifact
        uses: actions/upload-artifact@v6
        with:
          name: armis-security-results
          path: armis-results.sarif
          retention-days: ${{ inputs.artifact-retention-days }}

      - name: Analyze Scan Results
        id: scan_analysis
        if: always()
        run: |
          # Check if SARIF file exists and has valid JSON results
          if [ -s armis-results.sarif ]; then
            if RESULTS=$(jq -r '.runs[0].results | length' armis-results.sarif 2>/dev/null); then
              echo "has_results=true" >> $GITHUB_OUTPUT
            else
              RESULTS=0
              echo "has_results=false" >> $GITHUB_OUTPUT
            fi
            echo "results_count=$RESULTS" >> $GITHUB_OUTPUT
          else
            echo "results_count=0" >> $GITHUB_OUTPUT
            echo "has_results=false" >> $GITHUB_OUTPUT
          fi

      - name: Check for Failures
        if: always()
        env:
          SCAN_OUTCOME: ${{ steps.armis_scan.outcome }}
          HAS_RESULTS: ${{ steps.scan_analysis.outputs.has_results }}
          RESULTS_COUNT: ${{ steps.scan_analysis.outputs.results_count }}
          FAIL_ON: ${{ inputs.fail-on }}
        run: |
          if [ "$SCAN_OUTCOME" = "failure" ] || [ "$SCAN_OUTCOME" = "cancelled" ]; then
            if [ "$HAS_RESULTS" = "false" ] || [ "${RESULTS_COUNT:-0}" = "0" ]; then
              # Scan failed without producing results - likely timeout or API error
              echo "::error::Armis scan failed (timeout, API error, or other issue). Check the 'Run Armis Security Scan' step for details."
              exit 1
            else
              # Scan completed but found vulnerabilities above threshold
              echo "::error::Security vulnerabilities detected by Armis (threshold: $FAIL_ON). Found $RESULTS_COUNT issues."
              exit 1
            fi
          fi

          echo "Scan completed successfully with no issues above threshold."
